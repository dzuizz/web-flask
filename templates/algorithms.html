{% extends 'layout.html' %}

{% block content %}
{{ super() }}

<main class="fullscreen">
    <div class="flex flex-wrap">
        {% for algorithm in learnt_algorithms %}
            <button class="m-2 family-link {{ loop.cycle('border-green-500 hover:bg-green-500', 'border-sky-500 hover:bg-sky-500', 'border-amber-500 hover:bg-amber-500', 'border-red-400 hover:bg-red-400') }}" type="button" name="{{ algorithm.name }}"><a href="#{{ algorithm.id }}" class="mx-1">{{ algorithm.name }}</a></button>
        {% endfor %}
    </div>
    
    <div class="list-none m-5 font-mono"> <!-- Binary Search -->
        <h1 class="text-3xl font-medium uppercase" id="binary-search">Binary Search</h1>
        <p class="text-base m-4">
            Binary search is a search algorithm that finds the position of a target value within a sorted array.<br>
            <h3 class="text-3xl ml-2 mb-2 font-comfortaa">Here is an example.</h3>
            <pre class="m-2 text-base">
Given a sorted array of size <b>N</b> and a target value <b>X</b>, find the location of <b>X</b> in the array.<br>
Input:
  N X
  A<sub>1</sub> A<sub>2</sub> ... A<sub>N</sub>
</pre>
        </p>
        <pre class="syntax text-wrap z-[-1] whitespace-pre-wrap pl-8">
            <code class="text-white m-0 p-0 font-mono border-0 font-[100%] align-baseline hljs xml">
#include&#60;iostream&#62;
using namespace std;

int main() {
    int n, x; cin >> n >> x;
    int a[n];
    for(int i = 0; i < n; i++) {
        cin >> a[i];
    }

    int lf = 0, rg = n-1;
    while (lf < rg) {
        int mid = (lf + rg) / 2;
        if (a[mid] >= x) {
            rg = mid;
        } else {
            lf = mid + 1;
        }
    }
    cout << lf << endl; <span class="text-green-600">// or rg</span>
}
            </code>
        </pre>
    </div>

    <div class="list-none m-5 font-mono"> <!-- DFS -->
        <h1 class="text-3xl font-medium uppercase" id="depth-first-search">Depth First Search</h1>
        <p class="text-base m-4">
            Depth First Search is a graph traversal algorithm that finds the shortest path from one point to another in an unweighted graph.<br>
            <h3 class="text-3xl ml-2 mb-2 font-comfortaa">Here is an example.</h3>
            <pre class="m-2 text-base">
Given a graph of <b>N</b> nodes connected by <b>M</b> bidirectional edges which connect nodes <b>P<sub class="italic">i</sub></b> and <b>Q<sub class="italic">i</sub></b>, find the shortest path from node <b>S</b> to node <b>E</b>.
Input:
  N M
  S E

  P<sub>1</sub> Q<sub>1</sub>
  P<sub>2</sub> Q<sub>2</sub>
  ...
  P<sub>M</sub> Q<sub>M</sub>
</pre>
        </p>
        <pre class="syntax text-wrap z-[-1] whitespace-pre-wrap pl-8">
            <code class="text-white m-0 p-0 font-mono border-0 font-[100%] align-baseline hljs xml">
#include&#60;iostream&#62;
#include&#60;vector&#62;
using namespace std;

vector&#60;vector&#60;int&#62; &#62; adj;
bool visited[n];
const int INF = 1e9;
int S, E;

int dfs(int cur) {
    visited[cur] = true;
    if (cur == E) {
        return 0;
    }
    int res = INF;
    for (int i = 0; i < adj[cur].size(); i++) {
        int next = adj[cur][i];
        if (!visited[next]) {
            int dis = dfs(next);
            if (dis != -1) {
                res = min(res, dis + 1);
            }
        }
    }
    if (res == INF) return -1;
    return res;
}

int main() {
    int n, m; cin >> n >> m;
    visited = vector&#60;int&#62;(n);

    for (int i = 0; i < m; i++) {
        int p, q; cin >> p >> q;
        adj[p].push_back(q);
        adj[q].push_back(p);
    }

    cin >> S >> E;
    cout << dfs(S) << endl;
}
            </code>
        </pre>
    </div>
    
    <div class="list-none m-5 font-mono"> <!-- BFS -->
        <h1 class="text-3xl font-medium uppercase" id="breadth-first-search">Breadth First Search</h1>
        <p class="text-base m-4">
            Breadth First Search, just like Depth First Search, is a graph traversal algorithm that finds the shortest path from one point to another in an unweighted graph.
            <h3 class="text-3xl ml-2 mb-2 font-comfortaa">Here is an example.</h3>
            <pre class="m-2 text-base">
Given a graph of N nodes connected by M bidirectional edges which connect nodes P<sub class="italic">i</sub> and Q<sub class="italic">i</sub>, find the shortest path from node S to node E.
Input:
  N M
  S E

  P<sub>1</sub> Q<sub>1</sub>
  P<sub>2</sub> Q<sub>2</sub>
  ...
  P<sub>M</sub> Q<sub>M</sub>
</pre>
        </p>
        <pre class="syntax text-wrap z-[-1] whitespace-pre-wrap pl-8">
            <code class="text-white m-0 p-0 font-mono border-0 font-[100%] align-baseline hljs xml">
#include&#60;iostream&#62;
#include&#60;queue&#62;
using namespace std;
typedef pair&#60;int, int&#62; ii;

#define fi node
#define se dist

int main() {
    int n, m; cin >> n >> m;
    int s, e; cin >> s >> e;

    vector&#60;vector&#60;int&#62; &#62; adj;
    vector&#60;bool&#62; visited;

    for (int i = 0; i < n; i++) {
        int p, q; cin >> p >> q;
        adj[p].push_back(q);
        adj[q].push_back(p);
    }

    queue&#60;int&#62; q;
    q.push_back(ii(s, 0));
    visited[s] = 1;
    while(!q.empty()) {
        ii cur = q.top(); q.pop();
        if (cur.node == e) {
            cout << cur.dist << endl;
            return 0;
        }
        for (int i = 0; i < adj[cur.node].size(); i++) {
            int next = adj[cur.node][i];
            if (!visited[next]) {
                q.push_back(ii(next, cur.dist + 1));
                visited[next] = 1;
            }
        }
    }
}
            </code>
        </pre>
    </div>
    
    <div class="list-none m-5 font-mono" id="dijkstra"> <!-- Dijkstra -->
        <h1 class="text-3xl font-medium uppercase" id="">Dijkstra</h1>
        <p class="text-base m-4">
            Dijkstra
            <h3 class="text-3xl ml-2 mb-2 font-comfortaa">Here is an example.</h3>
            <pre class="m-2 text-base">
Given a weighted graph of N nodes connected by M bidirectional edges with W<sub class="italic">i</sub> which connect nodes P<sub class="italic">i</sub> and Q<sub class="italic">i</sub>, find the shortest path from node S to node E.
Input:
  N M
  P<sub>1</sub> Q<sub>1</sub> W<sub>1</sub>
  P<sub>2</sub> Q<sub>2</sub> W<sub>2</sub>
  ...
  P<sub>M</sub> Q<sub>M</sub> W<sub>M</sub>
</pre>
        <pre class="syntax text-wrap z-[-1] whitespace-pre-wrap pl-8">
            <code class="text-white m-0 p-0 font-mono border-0 font-[100%] align-baseline hljs xml">
#include&#60;iostream&#62;
#include&#60;vector&#62;
#include&#60;queue&#62;
using namespace std;
typedef pair&#60;int, int&#62; ii;

#define fi node
#define se dist

vector&#60;vector&#60;ii&#62;&#62; adj;
const int INF = 1e9;

int main() {
    int n, m; cin >> n >> m;

    vector&#60;int&#62; distV(n);

    for (int i = 0; i < n; i++) distV[i] = INF;
    for (int i = 0; i < m; i++) {
        int p, q, w; cin >> p >> q >> w;
        adj[p].push_back(ii(q, w));
        adj[q].push_back(ii(p, w));
    }

    priority_queue&#60;ii&#62; q;
    q.push_back(ii(-s, 0));

    while(!q.empty()) {
        ii cur = q.top(); q.pop();
        int curNode = -cur.node;
        int curDist = cur.dist;
        if (curNode == e) {
            cout << curDist << endl;
            return 0;
        }
        for (int i = 0; i < adj[curNode].size(); i++) {
            int next = adj[curNode][i].node;
            int w = adj[curNode][i].dist;
            if (curDist + w < dist[next]) {
                dist[next] = cur.dist + w;
                q.push_back(ii(-next, dist[next]));
            }
        }
    }
}
</code>
        </pre>
    </div>

    <div class="list-none m-5 font-mono"> <!-- Floyd Warshall -->
        <h1 class="text-3xl font-medium uppercase" id="floyd-warshall-algorithm">Floyd Warshall Algorithm</h1>
        <p class="text-base m-4">
            Floyd Warshall Algorithm
            <h3 class="text-3xl ml-2 mb-2 font-comfortaa">Here is an example.</h3>
            <p class="text-base m-2">
                Given an undirected graph of size r and c, find the shortest path between two points in each given query of the q queries.
                Input:<br>
                &#11;&#11;r c<br>
                &#11;&#11;A<sub>1, 1</sub> A<sub>1, 2</sub> ... <sub>1, </sub>
            </p>
        </p>
        <pre class="syntax text-wrap z-[-1] whitespace-pre-wrap pl-8">
            <code class="text-white m-0 p-0 font-mono border-0 font-[100%] align-baseline hljs xml">
    #include&#60;iostream&#62;
    using namespace std;

    int main() {
        
    }
            </code>
        </pre>
    </div>

    <div class="list-none m-5 font-mono"> <!-- Bellman Ford -->
        <h1 class="text-3xl font-medium uppercase" id="bellman-ford-algorithm">Bellman Ford Algorithm</h1>
        <p class="text-base m-4">
            Bellman Ford Algorithm
            <h3 class="text-3xl ml-2 mb-2 font-comfortaa">Here is an example.</h3>
        </p>
        <pre class="syntax text-wrap z-[-1] whitespace-pre-wrap pl-8">
            <code class="text-white m-0 p-0 font-mono border-0 font-[100%] align-baseline hljs xml">
    #include&#60;iostream&#62;
    using namespace std;

    int main() {

    }
            </code>
        </pre>
    </div>

    <div class="list-none m-5 font-mono"> <!-- Dynamic Programming -->
        <h1 class="text-3xl font-medium uppercase" id="dynamic-programming">Dynamic Programming</h1>
        <p class="text-base m-4">
            Dynamic Programming
            <h3 class="text-3xl ml-2 mb-2 font-comfortaa">Here is an example.</h3>
        </p>
        <pre class="syntax text-wrap z-[-1] whitespace-pre-wrap pl-8">
            <code class="text-white m-0 p-0 font-mono border-0 font-[100%] align-baseline hljs xml">
    #include&#60;iostream&#62;
    using namespace std;

    int main() {
        
    }
            </code>
        </pre>
    </div>

    <div class="list-none m-5 font-mono"> <!-- Segment Tree -->
        <h1 class="text-3xl font-medium uppercase" id="segment-tree">Segment Tree</h1>
        <p class="text-base m-4">
            Segment Tree
            <h3 class="text-3xl ml-2 mb-2 font-comfortaa">Here is an example.</h3>
        </p>
        <pre class="syntax text-wrap z-[-1] whitespace-pre-wrap pl-8">
            <code class="text-white m-0 p-0 font-mono border-0 font-[100%] align-baseline hljs xml">
    #include&#60;iostream&#62;
    using namespace std;

    int main() {

    }
            </code>
        </pre>
    </div>

    <div class="list-none m-5 font-mono"> <!-- Minimum Spanning Tree -->
        <h1 class="text-3xl font-medium uppercase" id="minimum-spanning-tree">Minimum Spanning Tree</h1>
        <p class="text-base m-4">

            <h3 class="text-3xl ml-2 mb-2 font-comfortaa">Here is an example.</h3>
        </p>
        <pre class="syntax text-wrap z-[-1] whitespace-pre-wrap pl-8">
            <code class="text-white m-0 p-0 font-mono border-0 font-[100%] align-baseline hljs xml">
    #include&#60;iostream&#62;
    using namespace std;

    int main() {
        
    }
            </code>
        </pre>
    </div>

    <div class="list-none m-5 font-mono"> <!-- Disjoint Set Union -->
        <h1 class="text-3xl font-medium uppercase" id="disjoint-set-union">Disjoint Set Union</h1>
        <p class="text-base m-4">
            Disjoint Set Union
            <h3 class="text-3xl ml-2 mb-2 font-comfortaa">Here is an example.</h3>
            <p class="m-2 text-base">There are <b>n</b> kingdom. After every fight between two kingdom, the winner will take the defeated kingdom's resources<br>
                                 In each fight, the kingdom with more resources will win.<br>
                                 Given the number of kingdoms, their initial resources and the fights,<br>
                                 Find the kingdom with the most resources at the end.<br>
                                 Input:<br>
                                 &#11;&#11;N M<br>
                                 &#11;&#11;A<sub>N</sub> A<sub>N-1</sub> A<sub>N-2</sub> ... A<sub>1</sub><br><br>
                                 &#11;&#11;P<sub>1</sub> Q<sub>1</sub><br>
                                 &#11;&#11;P<sub>2</sub> Q<sub>2</sub><br>
                                 &#11;&#11;...<br>
                                 &#11;&#11;P<sub>N</sub> Q<sub>N</sub><br>
            </p>
        </p>
        <pre class="syntax text-wrap z-[-1] whitespace-pre-wrap pl-8">
            <code class="text-white m-0 p-0 border-0 font-mono font-[100%] align-baseline hljs xml">
#include&#60;iostream&#62;
#include&#60;vector&#62;
using namespace std;
typedef pair&#60;int, int&#62; ii;

#define fi first
#define se second

vector&#60;int&#62; dsu; <span class="text-green-600">// resources, the kingdom it is under</span>

int find(int n) {
    if (dsu[n] == n) return n;
    return dsu[n] = find(dsu[n]);
}

void merge(int x, int y) {
    x = find(x); y = find(y);
    if (x == y) return;
    if (dsu[x].fi < dsu[y].fi) {
        swap(x, y);
    }
    dsu[x].fi += dsu[y].fi;
    dsu[y].se = x;
}

int main() {
    int n, m; cin >> n >> m;
    dsu.resize(n);

    for (int i = 0; i < n; i++) {
        cin >> dsu[i].fi;
        dsu[i].se = i;
    }

    for (int i = 0; i < m; i++) {
        int a, b; cin >> a >> b;
        merge(a, b);
    }
}
            </code>
        </pre>
    </div>

    <div class="list-none m-5 font-mono"> <!-- Insertion Sort -->
        <h1 class="text-3xl font-medium uppercase" id="insertion-sort">Insertion Sort</h1>
        <p class="text-base m-4">
            Insertion Sort
            <h3 class="text-3xl ml-2 mb-2 font-comfortaa">Here is an example.</h3>
        </p>
        <pre class="syntax text-wrap z-[-1] whitespace-pre-wrap pl-8">
            <code class="text-white m-0 p-0 font-mono border-0 font-[100%] align-baseline hljs xml">
    #include&#60;iostream&#62;
    using namespace std;

    int main() {

    }
            </code>
        </pre>
    </div>

    <div class="list-none m-5 font-mono"> <!-- Bubble Sort -->
        <h1 class="text-3xl font-medium uppercase" id="bubble-sort">Bubble Sort</h1>
        <p class="text-base m-4"<pre class="syntax text-wrap z-[-1] whitespace-pre-wrap pl-8">

            <h3 class="text-3xl ml-2 mb-2 font-comfortaa">Here is an example.</h3>
        </p>
        <pre class="syntax text-wrap z-[-1] whitespace-pre-wrap pl-8">
            <code class="text-white m-0 p-0 font-mono border-0 font-[100%] align-baseline hljs xml">
    #include&#60;iostream&#62;
    using namespace std;

    int main() {
        
    }
            </code>
        </pre>
    </div>
</main>
{% endblock %}